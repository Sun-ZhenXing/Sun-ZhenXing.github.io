import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as h,c as p,b as i,a,w as e,e as d,d as n}from"./app-mQJDQ8JG.js";const k={},r=i("p",null,"《Vue.js 设计与实现》的解析。",-1),c={class:"table-of-contents"},o=d(`<div class="hint-container tip"><p class="hint-container-title">书籍推荐</p><p>《Vue.js 设计与实现》这本书是 Vue 核心开发团队成员霍春阳编写的，没有源码阅读，直接分析了 Vue 3 的一些设计哲学。</p><p>《Vue.js 技术内幕》则是源码阅读，从 Vue 的源码来分析 Vue 的一些核心实现。</p></div><h2 id="1-框架设计概述" tabindex="-1"><a class="header-anchor" href="#1-框架设计概述"><span>1. 框架设计概述</span></a></h2><h3 id="11-权衡的艺术" tabindex="-1"><a class="header-anchor" href="#11-权衡的艺术"><span>1.1 权衡的艺术</span></a></h3><blockquote><p>框架的设计本身就是一种权衡的艺术。<br><cite>——尤雨溪</cite></p></blockquote><h4 id="111-命令式和声明式" tabindex="-1"><a class="header-anchor" href="#111-命令式和声明式"><span>1.1.1 命令式和声明式</span></a></h4><p>命令式编程和声明式编程是两种不同的编程范式，Vue 给用户体验是声明式的，但是内部实现是命令式的。</p><p>命令式编程主要关注过程：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> div</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> document</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">innerHTML</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;Hello World&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  alert</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;Hello World&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>声明式编程主要关注结果：</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" data-title="vue" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;">click</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;Hello World&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Hello World</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="112-性能与可维护性" tabindex="-1"><a class="header-anchor" href="#112-性能与可维护性"><span>1.1.2 性能与可维护性</span></a></h4><p>命令式编程的性能更好，直接使用原生的 JavaScript 实现。而声名式编程的无论界面如何，其内部一定会实现命令式的逻辑代码，所以性能上会有一定的损耗。</p><p>命令式编程的可维护性远远大于命令式代码，因为其代码更加直观，更容易理解。</p><p>DOM 渲染方式的直观比较：</p><table><thead><tr><th>项目</th><th><code>innerHTML</code>（字符串模板）</th><th>虚拟 DOM</th><th>原生 JavaScript</th></tr></thead><tbody><tr><td>心智负担</td><td>中等</td><td>小</td><td>大</td></tr><tr><td>性能</td><td>低</td><td>可接受，不错</td><td>高</td></tr><tr><td>可维护性</td><td>中等</td><td>强</td><td>高</td></tr></tbody></table><h4 id="113-运行时和编译时" tabindex="-1"><a class="header-anchor" href="#113-运行时和编译时"><span>1.1.3 运行时和编译时</span></a></h4><p>运行时渲染指的是利用 <code>render</code> 函数将虚拟 DOM 渲染成真实 DOM 的过程。这个过程没有编译的内容，无法分析用户提供的内容。</p><p>编译时渲染指的是将模板编译成 DOM 元素。这个过程会分析用户提供的内容，理论上性能更好。例如 Svelte 就是编译时渲染，但是作者也在书中强调了 Svelte 的性能没有达到预期的效果。</p><p>还有一种方式，即运行时 + 编译时，这个过程可分为两个阶段：</p><ol><li>将模板编译成 <code>render</code> 函数</li><li>利用 <code>render</code> 函数将虚拟 DOM 渲染成真实 DOM</li></ol><p>这也是 Vue 的主要实现方式。</p><h3 id="12-框架设计的核心要素" tabindex="-1"><a class="header-anchor" href="#12-框架设计的核心要素"><span>1.2 框架设计的核心要素</span></a></h3><h4 id="121-控制代码体积" tabindex="-1"><a class="header-anchor" href="#121-控制代码体积"><span>1.2.1 控制代码体积</span></a></h4><p>使用环境变量（如 <code>__DEV__</code>）和 <strong>摇树优化</strong>（Tree Shaking）来控制代码体积。</p><h4 id="122-输出不同的构建产物" tabindex="-1"><a class="header-anchor" href="#122-输出不同的构建产物"><span>1.2.2 输出不同的构建产物</span></a></h4><p>通过构建不同的打包产物来应对不同的使用场景（如 CommonJS、ES Module、UMD、Runtime 等）。</p><h4 id="123-错误提示与处理" tabindex="-1"><a class="header-anchor" href="#123-错误提示与处理"><span>1.2.3 错误提示与处理</span></a></h4><p>Vue 内部提供了一个同意的错误处理接口 <code>callWithErrorHandling</code>，用于处理错误。</p><h4 id="124-提升用户开发体验" tabindex="-1"><a class="header-anchor" href="#124-提升用户开发体验"><span>1.2.4 提升用户开发体验</span></a></h4><p>内部使用 TypeScript 进行开发，提供了类型提示。包含了大量类型校验，可以保证项目的可维护性，提升用户开发体验，降低用户心智负担。</p><h3 id="13-vuejs-3-的设计思路" tabindex="-1"><a class="header-anchor" href="#13-vuejs-3-的设计思路"><span>1.3 Vue.js 3 的设计思路</span></a></h3><h4 id="131-描述-ui-的形式" tabindex="-1"><a class="header-anchor" href="#131-描述-ui-的形式"><span>1.3.1 描述 UI 的形式</span></a></h4><p>声名式的模板描述：</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" data-title="vue" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">tid</span><span style="--shiki-light:#032F62;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{ </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">active</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">isActive</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> }</span><span style="--shiki-light:#032F62;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;">click</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">handleClick</span><span style="--shiki-light:#032F62;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  {{ text }}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令式的 <code>render</code> 函数：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">h</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">      id</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">tid</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">      class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        active</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">isActive</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">      onClick</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">handleClick</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="132-初始化渲染器" tabindex="-1"><a class="header-anchor" href="#132-初始化渲染器"><span>1.3.2 初始化渲染器</span></a></h4><p>渲染器是 <code>createRenderer</code> 函数的返回值，它是一个对象，包含了 <code>render</code> 方法。</p><p>渲染函数需要两个参数，第一个参数是虚拟节点 <code>vnode</code>，第二个参数是容器 <code>container</code>，是真实的 DOM 元素。渲染函数的作用是将虚拟节点渲染成真实节点，然后挂载到容器上。抽象一点来说就是把 <code>vnode</code> 挂载到 <code>container</code> 上。</p><h4 id="133-组件的本质" tabindex="-1"><a class="header-anchor" href="#133-组件的本质"><span>1.3.3 组件的本质</span></a></h4><p>Vue 以组件作为最小颗粒，Vue 程序的本质就是大量的组件渲染。</p><p>组件就是一组 DOM 元素的封装。一个组件就是一个 JavaScript 对象（VNode），内部封装了 DOM 元素的结构、样式、事件等。</p><h4 id="134-模板的工作原理" tabindex="-1"><a class="header-anchor" href="#134-模板的工作原理"><span>1.3.4 模板的工作原理</span></a></h4><p>这部分在上一节已经讲过了，可以阅读原著。</p>`,44);function B(g,u){const s=l("router-link");return h(),p("div",null,[r,i("nav",c,[i("ul",null,[i("li",null,[a(s,{to:"#1-框架设计概述"},{default:e(()=>[n("1. 框架设计概述")]),_:1}),i("ul",null,[i("li",null,[a(s,{to:"#11-权衡的艺术"},{default:e(()=>[n("1.1 权衡的艺术")]),_:1})]),i("li",null,[a(s,{to:"#12-框架设计的核心要素"},{default:e(()=>[n("1.2 框架设计的核心要素")]),_:1})]),i("li",null,[a(s,{to:"#13-vuejs-3-的设计思路"},{default:e(()=>[n("1.3 Vue.js 3 的设计思路")]),_:1})])])])])]),o])}const E=t(k,[["render",B],["__file","vue-design-and-implement.html.vue"]]),m=JSON.parse('{"path":"/posts/frontend/vue/vue-design-and-implement.html","title":"Vue.js 设计与实现","lang":"zh-CN","frontmatter":{"title":"Vue.js 设计与实现","date":"2023-03-27T00:00:00.000Z","category":["前端","Vue"],"tag":["前端","Vue","Vue3"],"description":"《Vue.js 设计与实现》的解析。","head":[["meta",{"property":"og:url","content":"https://blog.alexsun.top/posts/frontend/vue/vue-design-and-implement.html"}],["meta",{"property":"og:site_name","content":"鸭梨"}],["meta",{"property":"og:title","content":"Vue.js 设计与实现"}],["meta",{"property":"og:description","content":"《Vue.js 设计与实现》的解析。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-02T16:16:12.000Z"}],["meta",{"property":"article:author","content":"Alex Sun"}],["meta",{"property":"article:tag","content":"前端"}],["meta",{"property":"article:tag","content":"Vue"}],["meta",{"property":"article:tag","content":"Vue3"}],["meta",{"property":"article:published_time","content":"2023-03-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-02T16:16:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue.js 设计与实现\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-02T16:16:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Alex Sun\\",\\"url\\":\\"https://blog.alexsun.top/\\"}]}"]]},"headers":[{"level":2,"title":"1. 框架设计概述","slug":"1-框架设计概述","link":"#1-框架设计概述","children":[{"level":3,"title":"1.1 权衡的艺术","slug":"11-权衡的艺术","link":"#11-权衡的艺术","children":[]},{"level":3,"title":"1.2 框架设计的核心要素","slug":"12-框架设计的核心要素","link":"#12-框架设计的核心要素","children":[]},{"level":3,"title":"1.3 Vue.js 3 的设计思路","slug":"13-vuejs-3-的设计思路","link":"#13-vuejs-3-的设计思路","children":[]}]}],"git":{"createdTime":1679899044000,"updatedTime":1709396172000,"contributors":[{"name":"Sun-ZhenXing","email":"1006925066@qq.com","commits":2}]},"readingTime":{"minutes":3.39,"words":1017},"filePathRelative":"posts/frontend/vue/vue-design-and-implement.md","localizedDate":"2023年3月27日","excerpt":"<!-- markdownlint-disable MD033 -->\\n<p>《Vue.js 设计与实现》的解析。</p>\\n","autoDesc":true}');export{E as comp,m as data};
