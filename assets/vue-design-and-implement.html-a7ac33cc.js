import{_ as p,Y as o,Z as c,$ as l,a1 as a,a0 as s,a3 as t,a4 as i,E as d,a2 as e}from"./framework-f3c57110.js";const r={},u=a("p",null,"《Vue.js 设计与实现》的解析。",-1),k={class:"table-of-contents"},h=i(`<div class="hint-container tip"><p class="hint-container-title">书籍推荐</p><p>《Vue.js 设计与实现》这本书是 Vue 核心开发团队成员霍春阳编写的，没有源码阅读，直接分析了 Vue 3 的一些设计哲学。</p><p>《Vue.js 技术内幕》则是源码阅读，从 Vue 的源码来分析 Vue 的一些核心实现。</p></div><h2 id="_1-框架设计概述" tabindex="-1"><a class="header-anchor" href="#_1-框架设计概述" aria-hidden="true">#</a> 1. 框架设计概述</h2><h3 id="_1-1-权衡的艺术" tabindex="-1"><a class="header-anchor" href="#_1-1-权衡的艺术" aria-hidden="true">#</a> 1.1 权衡的艺术</h3><blockquote><p>框架的设计本身就是一种权衡的艺术。 <cite>——尤雨溪</cite></p></blockquote><h4 id="_1-1-1-命令式和声明式" tabindex="-1"><a class="header-anchor" href="#_1-1-1-命令式和声明式" aria-hidden="true">#</a> 1.1.1 命令式和声明式</h4><p>命令式编程和声明式编程是两种不同的编程范式，Vue 给用户体验是声明式的，但是内部实现是命令式的。</p><p>命令式编程主要关注过程：</p><div class="language-javascript" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span>
div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">&#39;Hello World&#39;</span>
div<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;Hello World&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>声明式编程主要关注结果：</p><div class="language-vue" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>alert(&#39;Hello World&#39;)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  Hello World
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h4 id="_1-1-2-性能与可维护性" tabindex="-1"><a class="header-anchor" href="#_1-1-2-性能与可维护性" aria-hidden="true">#</a> 1.1.2 性能与可维护性</h4><p>命令式编程的性能更好，直接使用原生的 JavaScript 实现。而声名式编程的无论界面如何，其内部一定会实现命令式的逻辑代码，所以性能上会有一定的损耗。</p><p>命令式编程的可维护性远远大于命令式代码，因为其代码更加直观，更容易理解。</p><p>DOM 渲染方式的直观比较：</p><table><thead><tr><th>项目</th><th><code>innerHTML</code>（字符串模板）</th><th>虚拟 DOM</th><th>原生 JavaScript</th></tr></thead><tbody><tr><td>心智负担</td><td>中等</td><td>小</td><td>大</td></tr><tr><td>性能</td><td>低</td><td>可接受，不错</td><td>高</td></tr><tr><td>可维护性</td><td>中等</td><td>强</td><td>高</td></tr></tbody></table><h4 id="_1-1-3-运行时和编译时" tabindex="-1"><a class="header-anchor" href="#_1-1-3-运行时和编译时" aria-hidden="true">#</a> 1.1.3 运行时和编译时</h4><p>运行时渲染指的是利用 <code>render</code> 函数将虚拟 DOM 渲染成真实 DOM 的过程。这个过程没有编译的内容，无法分析用户提供的内容。</p><p>编译时渲染指的是将模板编译成 DOM 元素。这个过程会分析用户提供的内容，理论上性能更好。例如 Svelte 就是编译时渲染，但是作者也在书中强调了 Svelte 的性能没有达到预期的效果。</p><p>还有一种方式，即运行时 + 编译时，这个过程可分为两个阶段：</p><ol><li>将模板编译成 <code>render</code> 函数</li><li>利用 <code>render</code> 函数将虚拟 DOM 渲染成真实 DOM</li></ol><p>这也是 Vue 的主要实现方式。</p><h3 id="_1-2-框架设计的核心要素" tabindex="-1"><a class="header-anchor" href="#_1-2-框架设计的核心要素" aria-hidden="true">#</a> 1.2 框架设计的核心要素</h3><h4 id="_1-2-1-控制代码体积" tabindex="-1"><a class="header-anchor" href="#_1-2-1-控制代码体积" aria-hidden="true">#</a> 1.2.1 控制代码体积</h4><p>使用环境变量（如 <code>__DEV__</code>）和 <strong>摇树优化</strong>（Tree Shaking）来控制代码体积。</p><h4 id="_1-2-2-输出不同的构建产物" tabindex="-1"><a class="header-anchor" href="#_1-2-2-输出不同的构建产物" aria-hidden="true">#</a> 1.2.2 输出不同的构建产物</h4><p>通过构建不同的打包产物来应对不同的使用场景（如 CommonJS、ES Module、UMD、Runtime 等）。</p><h4 id="_1-2-3-错误提示与处理" tabindex="-1"><a class="header-anchor" href="#_1-2-3-错误提示与处理" aria-hidden="true">#</a> 1.2.3 错误提示与处理</h4><p>Vue 内部提供了一个同意的错误处理接口 <code>callWithErrorHandling</code>，用于处理错误。</p><h4 id="_1-2-4-提升用户开发体验" tabindex="-1"><a class="header-anchor" href="#_1-2-4-提升用户开发体验" aria-hidden="true">#</a> 1.2.4 提升用户开发体验</h4><p>内部使用 TypeScript 进行开发，提供了类型提示。包含了大量类型校验，可以保证项目的可维护性，提升用户开发体验，降低用户心智负担。</p><h3 id="_1-3-vue-js-3-的设计思路" tabindex="-1"><a class="header-anchor" href="#_1-3-vue-js-3-的设计思路" aria-hidden="true">#</a> 1.3 Vue.js 3 的设计思路</h3><h4 id="_1-3-1-描述-ui-的形式" tabindex="-1"><a class="header-anchor" href="#_1-3-1-描述-ui-的形式" aria-hidden="true">#</a> 1.3.1 描述 UI 的形式</h4><p>声名式的模板描述：</p><div class="language-vue" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>tid<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ active: isActive }<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  {{ text }}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>命令式的 <code>render</code> 函数：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tid<span class="token punctuation">,</span>
      <span class="token keyword">class</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">active</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>isActive
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token literal-property property">onClick</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-3-2-初始化渲染器" tabindex="-1"><a class="header-anchor" href="#_1-3-2-初始化渲染器" aria-hidden="true">#</a> 1.3.2 初始化渲染器</h4><p>渲染器是 <code>createRenderer</code> 函数的返回值，它是一个对象，包含了 <code>render</code> 方法。</p><p>渲染函数需要两个参数，第一个参数是虚拟节点 <code>vnode</code>，第二个参数是容器 <code>container</code>，是真实的 DOM 元素。渲染函数的作用是将虚拟节点渲染成真实节点，然后挂载到容器上。抽象一点来说就是把 <code>vnode</code> 挂载到 <code>container</code> 上。</p><h4 id="_1-3-3-组件的本质" tabindex="-1"><a class="header-anchor" href="#_1-3-3-组件的本质" aria-hidden="true">#</a> 1.3.3 组件的本质</h4><p>Vue 以组件作为最小颗粒，Vue 程序的本质就是大量的组件渲染。</p><p>组件就是一组 DOM 元素的封装。一个组件就是一个 JavaScript 对象（VNode），内部封装了 DOM 元素的结构、样式、事件等。</p><h4 id="_1-3-4-模板的工作原理" tabindex="-1"><a class="header-anchor" href="#_1-3-4-模板的工作原理" aria-hidden="true">#</a> 1.3.4 模板的工作原理</h4><p>这部分在上一节已经讲过了，可以阅读原著。</p>`,44);function v(_,g){const n=d("router-link");return o(),c("div",null,[u,l(" more "),a("nav",k,[a("ul",null,[a("li",null,[s(n,{to:"#_1-框架设计概述"},{default:t(()=>[e("1. 框架设计概述")]),_:1}),a("ul",null,[a("li",null,[s(n,{to:"#_1-1-权衡的艺术"},{default:t(()=>[e("1.1 权衡的艺术")]),_:1})]),a("li",null,[s(n,{to:"#_1-2-框架设计的核心要素"},{default:t(()=>[e("1.2 框架设计的核心要素")]),_:1})]),a("li",null,[s(n,{to:"#_1-3-vue-js-3-的设计思路"},{default:t(()=>[e("1.3 Vue.js 3 的设计思路")]),_:1})])])])])]),h])}const b=p(r,[["render",v],["__file","vue-design-and-implement.html.vue"]]);export{b as default};
