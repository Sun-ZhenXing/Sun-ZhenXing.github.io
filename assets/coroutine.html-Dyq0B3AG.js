import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as e,e as n}from"./app-mQJDQ8JG.js";const a={},t=n(`<h1 id="python-协程" tabindex="-1"><a class="header-anchor" href="#python-协程"><span>Python 协程</span></a></h1><h2 id="1-协程" tabindex="-1"><a class="header-anchor" href="#1-协程"><span>1. 协程</span></a></h2><p>协程是子例程的更一般形式。</p><p>子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" target="_blank" rel="noopener noreferrer">async def</a> 语句来实现。参见 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener noreferrer">PEP 492</a> <sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>。</p><ul><li><em>@3.5+</em> <strong>协程</strong>（coroutine）可以在多个位置上挂起和恢复执行</li><li><code>await</code> 表达式，<code>async for</code> 以及 <code>async with</code> 只能在协程函数体中使用</li><li>使用 <code>async def</code> 语法定义的函数总是为协程函数，即使它们不包含 <code>await</code> 或 <code>async</code> 关键字</li><li>在协程函数体中使用 <code>yield from</code> 表达式将引发 <code>SyntaxError</code></li></ul><p>详细解释见 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#coroutines" target="_blank" rel="noopener noreferrer">官方文档语言参考手册</a>。</p><h2 id="2-协程函数" tabindex="-1"><a class="header-anchor" href="#2-协程函数"><span>2. 协程函数</span></a></h2><p>返回一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine" target="_blank" rel="noopener noreferrer"><code>Coroutine</code></a> 对象的函数。</p><p>协程函数可通过 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" target="_blank" rel="noopener noreferrer"><code>async def</code></a> 语句来定义，并可能包含 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" target="_blank" rel="noopener noreferrer"><code>await</code></a>、<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" target="_blank" rel="noopener noreferrer"><code>async for</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-with" target="_blank" rel="noopener noreferrer"><code>async with</code></a> 关键字。这些特性是由 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener noreferrer">PEP 492</a> 引入的。</p><h2 id="3-pep-492" tabindex="-1"><a class="header-anchor" href="#3-pep-492"><span>3. PEP 492</span></a></h2><p>PEP 是 Python 语言发展的提案。</p><p><a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener noreferrer">PEP 492</a> 提出使用 <code>async</code> 和 <code>await</code> 语法实现协程，将协程作为 Python 中的一个正式的单独概念，并增加相应的支持语法。</p><p>该提案在 Python 3.5 版本实现。</p><h2 id="4-技巧" tabindex="-1"><a class="header-anchor" href="#4-技巧"><span>4. 技巧</span></a></h2><h3 id="41-在异步代码中调用同步函数" tabindex="-1"><a class="header-anchor" href="#41-在异步代码中调用同步函数"><span>4.1 在异步代码中调用同步函数</span></a></h3><p>对于一些同步函数，如果我们在异步代码中直接调用这些函数，会导致事件循环被阻塞，从而影响整个程序的性能。因此最好的方法是将这些函数放在线程中运行。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>由于 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-global-interpreter-lock" target="_blank" rel="noopener noreferrer">GIL</a> 的存在，<code>asyncio.to_thread()</code> 通常不会对 CPU 密集型函数产生显著的性能提升，故通常只能被用来将 I/O 密集型函数变为非阻塞的。但是，对于会释放 GIL 的扩展模块或无此限制的替代性 Python 实现来说，<code>asyncio.to_thread()</code> 也可被用于 CPU 密集型函数。</p></div><p>在 Python 3.9 之后，我们可以使用 <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.to_thread" target="_blank" rel="noopener noreferrer"><code>asyncio.to_thread()</code></a> 函数来在异步代码中调用同步函数<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>。这会默认使用 Python 的 <code>ThreadPoolExecutor</code> 来运行函数。</p><h3 id="42-在同步代码中调用异步函数" tabindex="-1"><a class="header-anchor" href="#42-在同步代码中调用异步函数"><span>4.2 在同步代码中调用异步函数</span></a></h3><p>有时，我们需要在同步代码中调用异步函数，这时我们可以使用 <code>asyncio.run()</code> 函数来运行异步函数。</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> asyncio</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> async_task</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Start task&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> asyncio.</span><span style="--shiki-light:#24292E;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;End task&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;"> __name__</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;__main__&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    asyncio.</span><span style="--shiki-light:#24292E;--shiki-dark:#61AFEF;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#61AFEF;">async_task</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">())</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，以上这种情况仅适用于代码在单个线程中运行，如果代码在多个线程中运行，我们可以使用 <code>asyncio.run_coroutine_threadsafe()</code> 函数来运行异步函数。</p><p>注意，此时协程必须运行在一个正在工作的事件循环中，否则会引发 <code>RuntimeError</code> 异常或者死锁。因此下面的代码用于在一个线程调用正在另一个线程中运行的事件循环。</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> asyncio</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> typing </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Any, Coroutine, TypeVar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">T </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#61AFEF;"> TypeVar</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;T&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> coro_to_sync</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    coro</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: Coroutine[Any, Any, T],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    loop</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: asyncio.AbstractEventLoop </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> None</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> None</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) -&gt; T:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">    &quot;&quot;&quot;将协程转换为同步函数，此函数只由主线程调用&quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    loop </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> loop </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> asyncio.</span><span style="--shiki-light:#24292E;--shiki-dark:#61AFEF;">get_event_loop</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    future </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> asyncio.</span><span style="--shiki-light:#24292E;--shiki-dark:#61AFEF;">run_coroutine_threadsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(coro, loop)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> future.</span><span style="--shiki-light:#24292E;--shiki-dark:#61AFEF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>官方文档术语对照表，<a href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine" target="_blank" rel="noopener noreferrer">https://docs.python.org/zh-cn/3/glossary.html#term-coroutine</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.to_thread" target="_blank" rel="noopener noreferrer">https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.to_thread</a> <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li></ol></section>`,26),o=[t];function r(l,h){return i(),e("div",null,o)}const d=s(a,[["render",r],["__file","coroutine.html.vue"]]),k=JSON.parse('{"path":"/posts/python/notebook/async/coroutine.html","title":"Python 协程","lang":"zh-CN","frontmatter":{"description":"Python 协程 1. 协程 协程是子例程的更一般形式。 子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过 async def 语句来实现。参见 PEP 492 [1]。 @3.5+ 协程（coroutine）可以在多个位置上挂起和恢复执行 await 表达式，async for 以及 async with...","head":[["meta",{"property":"og:url","content":"https://blog.alexsun.top/posts/python/notebook/async/coroutine.html"}],["meta",{"property":"og:site_name","content":"鸭梨"}],["meta",{"property":"og:title","content":"Python 协程"}],["meta",{"property":"og:description","content":"Python 协程 1. 协程 协程是子例程的更一般形式。 子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过 async def 语句来实现。参见 PEP 492 [1]。 @3.5+ 协程（coroutine）可以在多个位置上挂起和恢复执行 await 表达式，async for 以及 async with..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-29T10:37:48.000Z"}],["meta",{"property":"article:author","content":"Alex Sun"}],["meta",{"property":"article:modified_time","content":"2024-05-29T10:37:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Python 协程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-29T10:37:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Alex Sun\\",\\"url\\":\\"https://blog.alexsun.top/\\"}]}"]]},"headers":[{"level":2,"title":"1. 协程","slug":"1-协程","link":"#1-协程","children":[]},{"level":2,"title":"2. 协程函数","slug":"2-协程函数","link":"#2-协程函数","children":[]},{"level":2,"title":"3. PEP 492","slug":"3-pep-492","link":"#3-pep-492","children":[]},{"level":2,"title":"4. 技巧","slug":"4-技巧","link":"#4-技巧","children":[{"level":3,"title":"4.1 在异步代码中调用同步函数","slug":"41-在异步代码中调用同步函数","link":"#41-在异步代码中调用同步函数","children":[]},{"level":3,"title":"4.2 在同步代码中调用异步函数","slug":"42-在同步代码中调用异步函数","link":"#42-在同步代码中调用异步函数","children":[]}]}],"git":{"createdTime":1716979068000,"updatedTime":1716979068000,"contributors":[{"name":"Sun-ZhenXing","email":"1006925066@qq.com","commits":1}]},"readingTime":{"minutes":2.52,"words":757},"filePathRelative":"posts/python/notebook/async/coroutine.md","localizedDate":"2024年5月29日","excerpt":"\\n<h2>1. 协程</h2>\\n<p>协程是子例程的更一般形式。</p>\\n<p>子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过 <a href=\\"https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">async def</a> 语句来实现。参见 <a href=\\"https://www.python.org/dev/peps/pep-0492\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">PEP 492</a> <sup class=\\"footnote-ref\\"><a href=\\"#footnote1\\">[1]</a><a class=\\"footnote-anchor\\" id=\\"footnote-ref1\\"></a></sup><a class=\\"footnote-anchor\\" id=\\"footnote-ref1\\">。</a></p>","autoDesc":true}');export{d as comp,k as data};
